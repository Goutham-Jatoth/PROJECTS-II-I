import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class AdvancedChessGame extends JFrame {
    private JPanel boardPanel;
    private JButton[][] boardButtons;
    private String[][] boardPieces;
    private boolean whiteTurn = true;
    private int selectedRow = -1, selectedCol = -1;
    private JTextArea moveHistory;

    private final String[][] initialBoard = {
            {"♜","♞","♝","♛","♚","♝","♞","♜"},
            {"♟","♟","♟","♟","♟","♟","♟","♟"},
            {"","","","","","","",""},
            {"","","","","","","",""},
            {"","","","","","","",""},
            {"","","","","","","",""},
            {"♙","♙","♙","♙","♙","♙","♙","♙"},
            {"♖","♘","♗","♕","♔","♗","♘","♖"}
    };

    public AdvancedChessGame() {
        boardPieces = new String[8][8];
        for(int i=0;i<8;i++)
            System.arraycopy(initialBoard[i],0,boardPieces[i],0,8);
        initBoard();
        drawBoard();
        setTitle("♟ Advanced Chess Unicode Game");
        setSize(800,700);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        setVisible(true);
    }

    private void initBoard() {
        setLayout(new BorderLayout(10,10));
        boardPanel = new JPanel(new GridLayout(8,8));
        boardButtons = new JButton[8][8];

        for(int i=0;i<8;i++){
            for(int j=0;j<8;j++){
                JButton btn = new JButton();
                btn.setFont(new Font("SansSerif", Font.PLAIN, 36));
                btn.setFocusPainted(false);
                btn.setBackground((i+j)%2==0?Color.WHITE:Color.GRAY);
                int r=i,c=j;
                btn.addActionListener(e -> handleClick(r,c));
                boardButtons[i][j] = btn;
                boardPanel.add(btn);
            }
        }
        add(boardPanel, BorderLayout.CENTER);

        moveHistory = new JTextArea(10,20);
        moveHistory.setEditable(false);
        add(new JScrollPane(moveHistory), BorderLayout.EAST);

        JButton resetButton = new JButton("New Game");
        resetButton.addActionListener(e -> resetGame());
        add(resetButton, BorderLayout.SOUTH);
    }

    private void drawBoard() {
        for(int i=0;i<8;i++)
            for(int j=0;j<8;j++)
                boardButtons[i][j].setText(boardPieces[i][j]);
    }

    private void handleClick(int row, int col) {
        String clickedPiece = boardPieces[row][col];
        if(selectedRow==-1 && !clickedPiece.isEmpty()){
            if((whiteTurn && isWhite(clickedPiece)) || (!whiteTurn && isBlack(clickedPiece))){
                selectedRow=row; selectedCol=col;
                boardButtons[row][col].setBackground(Color.YELLOW);
            }
        } else if(selectedRow!=-1){
            if(isValidMove(selectedRow,selectedCol,row,col)){
                String movingPiece = boardPieces[selectedRow][selectedCol];
                // Pawn promotion
                if(movingPiece.equals("♙") && row==0) movingPiece="♕";
                if(movingPiece.equals("♟") && row==7) movingPiece="♛";

                boardPieces[row][col]=movingPiece;
                boardPieces[selectedRow][selectedCol]="";

                moveHistory.append((whiteTurn?"White: ":"Black: ") + movingPiece + " "+
                        (char)('a'+selectedCol)+(8-selectedRow)+" -> "+
                        (char)('a'+col)+(8-row)+"\n");

                if(isCheckmate(!whiteTurn)) {
                    JOptionPane.showMessageDialog(this,(whiteTurn?"White":"Black")+" wins by Checkmate!");
                    resetGame();
                } else if(isCheck(!whiteTurn)){
                    JOptionPane.showMessageDialog(this,(!whiteTurn?"White":"Black")+" is in Check!");
                }

                whiteTurn = !whiteTurn;
            }
            resetBoardColors();
            selectedRow=-1; selectedCol=-1;
            drawBoard();
        }
    }

    private void resetBoardColors(){
        for(int i=0;i<8;i++)
            for(int j=0;j<8;j++)
                boardButtons[i][j].setBackground((i+j)%2==0?Color.WHITE:Color.GRAY);
    }

    private boolean isWhite(String p){return "♔♕♖♗♘♙".contains(p);}
    private boolean isBlack(String p){return "♚♛♜♝♞♟".contains(p);}

    private boolean isValidMove(int fromRow,int fromCol,int toRow,int toCol){
        String p = boardPieces[fromRow][fromCol];
        if(p.isEmpty()) return false;
        String target = boardPieces[toRow][toCol];
        if(!target.isEmpty() && ((isWhite(p)&&isWhite(target))||(isBlack(p)&&isBlack(target)))) return false;

        int dr=toRow-fromRow; int dc=toCol-fromCol;

        switch(p){
            case "♙": return dc==0 && dr==-1 && target.isEmpty() || Math.abs(dc)==1 && dr==-1 && !target.isEmpty();
            case "♟": return dc==0 && dr==1 && target.isEmpty() || Math.abs(dc)==1 && dr==1 && !target.isEmpty();
            case "♖": return dr==0||dc==0;
            case "♜": return dr==0||dc==0;
            case "♘": case "♞": return Math.abs(dr)==2 && Math.abs(dc)==1 || Math.abs(dr)==1 && Math.abs(dc)==2;
            case "♗": case "♝": return Math.abs(dr)==Math.abs(dc);
            case "♕": case "♛": return dr==0||dc==0||Math.abs(dr)==Math.abs(dc);
            case "♔": case "♚": return Math.abs(dr)<=1 && Math.abs(dc)<=1;
            default: return false;
        }
    }

    private boolean isCheck(boolean blackKing){
        // Check if king is under attack
        String king = blackKing?"♚":"♔";
        int kr=-1,kc=-1;
        for(int i=0;i<8;i++)
            for(int j=0;j<8;j++)
                if(boardPieces[i][j].equals(king)){kr=i;kc=j;}
        for(int i=0;i<8;i++)
            for(int j=0;j<8;j++)
                if(!boardPieces[i][j].isEmpty() && ((blackKing && isWhite(boardPieces[i][j])) || (!blackKing && isBlack(boardPieces[i][j]))))
                    if(isValidMove(i,j,kr,kc)) return true;
        return false;
    }

    private boolean isCheckmate(boolean blackKing){
        if(!isCheck(blackKing)) return false;
        // Simple checkmate detection: if king has any valid move to escape
        String king = blackKing?"♚":"♔";
        int kr=-1,kc=-1;
        for(int i=0;i<8;i++)
            for(int j=0;j<8;j++)
                if(boardPieces[i][j].equals(king)){kr=i;kc=j;}
        for(int r=Math.max(0,kr-1);r<=Math.min(7,kr+1);r++)
            for(int c=Math.max(0,kc-1);c<=Math.min(7,kc+1);c++)
                if(isValidMove(kr,kc,r,c)){
                    String orig = boardPieces[r][c];
                    boardPieces[r][c]=king; boardPieces[kr][kc]="";
                    boolean stillCheck=isCheck(blackKing);
                    boardPieces[kr][kc]=king; boardPieces[r][c]=orig;
                    if(!stillCheck) return false;
                }
        return true;
    }

    private void resetGame(){
        for(int i=0;i<8;i++)
            System.arraycopy(initialBoard[i],0,boardPieces[i],0,8);
        moveHistory.setText("");
        whiteTurn=true;
        drawBoard();
    }

    public static void main(String[] args){
        SwingUtilities.invokeLater(() -> new AdvancedChessGame());
    }
}




















1. Cover Page

Project Title: Advanced Chess Game (Unicode Version)

Developer Name: [Your Name]

Roll Number: [Your Roll Number]

Department: [Your Department]

College: [Your College Name]

Semester / Year: [Semester & Year]

Submission Date: [Date]

2. Abstract

The Advanced Chess Game is a Java-based GUI application that allows two players to play chess on the same computer.
It uses Unicode symbols for all chess pieces, eliminating the need for external image files.

This project implements basic rules of chess, along with advanced features such as:

Pawn promotion

Check and Checkmate detection

Move history panel

Turn-based gameplay

Reset/New Game functionality

The system aims to enhance understanding of Java Swing, event handling, and logic implementation while providing an interactive user experience.

3. Objectives

To develop a fully functional Chess game using Java Swing.

To implement turn-based logic and basic chess rules.

To provide an interactive GUI using Unicode chess symbols.

To implement check, checkmate detection, and pawn promotion.

To display move history for both players.

To create a standalone application requiring no external resources.

4. Tools & Technologies

Programming Language: Java (JDK 8 or above)

GUI Framework: Swing (JFrame, JPanel, JButton, JTextArea)

IDE: NetBeans / Eclipse / IntelliJ IDEA (optional)

Concepts Used:

Object-Oriented Programming (Classes, Methods, Arrays)

Event Handling (ActionListener)

2D Array Manipulation for board and pieces

Conditional Logic for chess rules

Unicode symbols for graphical representation

5. Features of the System

8x8 Chess Board with Unicode symbols for all pieces.

Click-to-select and move pieces.

Turn-based gameplay: White moves first, then Black.

Legal move validation for all pieces.

Check and Checkmate detection.

Pawn promotion to queen when reaching the last rank.

Move history panel displays all moves in standard notation.

New Game button resets the board and clears move history.

No external image files required – fully Unicode-based GUI.

6. System Architecture / Flow Diagram
[Start] → [Initialize Board] → [Display GUI]
       → [Player Clicks Piece] → [Validate Move] 
       → [Update Board & Move History] 
       → [Check/Checkmate?] → [Next Player Turn] 
       → [Repeat] → [New Game / Exit]


Components:

GUI Layer: JFrame, JPanel, JButton, JTextArea

Data Layer: 2D array (String[][] boardPieces)

Logic Layer: Methods for validating moves, check/checkmate, pawn promotion

7. GUI Screenshots

(Insert screenshots from running the program)

Initial Board: Shows starting position of all pieces.

Move History Panel: Shows moves after each turn.

Pawn Promotion Example: Pawn reaching last rank becomes a queen.

Check/Checkmate Alerts: Dialog box shows when a king is in check or checkmate.

New Game Reset: Board and move history cleared.

8. Code Explanation

Main Class: AdvancedChessUnicode – handles GUI, game logic, and events.

Board Representation:

String[][] boardPieces – 8x8 array storing Unicode symbols.

JButton[][] boardButtons – 8x8 array for GUI buttons.

Key Methods:

handleClick(int row, int col) – Handles selecting and moving pieces.

isValidMove(int fromRow, int fromCol, int toRow, int toCol) – Validates piece movement.

isWhite(String piece) / isBlack(String piece) – Determines piece color.

isCheck(boolean blackKing) – Detects if the king is in check.

isCheckmate(boolean blackKing) – Detects checkmate and ends the game.

resetGame() – Resets board and move history.

drawBoard() – Updates GUI buttons with Unicode symbols.

9. Sample Output

Move Example:

White: ♙ e2 -> e4
Black: ♟ e7 -> e5
White: ♘ g1 -> f3


Check Example:

Dialog: Black is in Check!


Checkmate Example:

Dialog: White wins by Checkmate!


Pawn Promotion Example:

White pawn reaches rank 8 → becomes ♕ automatically

10. Advantages

Fully playable chess game without images.

Interactive GUI with move history.

Implements check, checkmate, and pawn promotion.

Turn-based gameplay ensures two-player functionality.

Easy to extend for castling or AI opponent.

11. Limitations

No AI or computer opponent – only two-player mode.

Castling is not fully implemented.

En passant move not supported.

Does not store games or export move history to file.

12. Conclusion

The Advanced Chess Game (Unicode Version) demonstrates a complete two-player chess application using Java Swing and Unicode symbols.
It includes essential chess rules, move validation, check/checkmate detection, and pawn promotion.
The system is easy to use, standalone, and ready for submission as a mini-project.

13. References

Oracle Java Documentation: https://docs.oracle.com/javase/8/docs/

Java Swing Tutorials: https://www.javatpoint.com/java-swing

Unicode Chess Symbols: https://en.wikipedia.org/wiki/Chess_symbols_in_Unicode

Java 2D Arrays and Event Handling Tutorials
